import{_ as c,r as o,o as l,c as i,a as n,b as s,w as e,d as a,e as r}from"./app-DPz2NTkK.js";const u="/images/interview/prototype.png",d="/images/interview/prototypechain.png",k="/images/interview/proto.png",v={},m=n("h1",{id:"javascript-原型-原型链-有什么特点",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#javascript-原型-原型链-有什么特点"},[n("span",null,"JavaScript 原型，原型链 ? 有什么特点？")])],-1),_={class:"table-of-contents"},h=r(`<h2 id="原型" tabindex="-1"><a class="header-anchor" href="#原型"><span>原型</span></a></h2><p>JavaScript 常被描述为一种基于原型的语言——每个对象拥有一个原型对象</p><p>当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾</p><p>准确地说，这些属性和方法定义在 Object 的构造器函数（constructor functions）之上的 prototype 属性上，而非实例对象本身</p><p>下面举个例子：</p><p>函数可以有属性。 每个函数都有一个特殊的属性叫作原型 prototype</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>doSomething<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>控制台输出</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token punctuation">{</span>
  <span class="token literal-property property">constructor</span><span class="token operator">:</span> ƒ <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token literal-property property">__proto__</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">constructor</span><span class="token operator">:</span> ƒ <span class="token function">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token literal-property property">hasOwnProperty</span><span class="token operator">:</span> ƒ <span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token literal-property property">isPrototypeOf</span><span class="token operator">:</span> ƒ <span class="token function">isPrototypeOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token literal-property property">propertyIsEnumerable</span><span class="token operator">:</span> ƒ <span class="token function">propertyIsEnumerable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token literal-property property">toLocaleString</span><span class="token operator">:</span> ƒ <span class="token function">toLocaleString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token literal-property property">toString</span><span class="token operator">:</span> ƒ <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token literal-property property">valueOf</span><span class="token operator">:</span> ƒ <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面这个对象，就是大家常说的原型对象</p><p>可以看到，原型对象有一个自有属性 constructor，这个属性指向该函数，如下图关系展示</p><p><img src="`+u+`" alt="图片"></p><h2 id="原型链" tabindex="-1"><a class="header-anchor" href="#原型链"><span>原型链</span></a></h2><p>原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法</p><p>在对象实例和它的构造器之间建立一个链接（它是<strong>proto</strong>属性，是从构造函数的 prototype 属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方法</p><p>下面举个例子：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">18</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 第二步 创建实例</span>
<span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;person&quot;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>根据代码，我们可以得到下图</p><p><img src="`+d+'" alt="图片"></p><p>下面分析一下：</p><ul><li><p>构造函数Person存在原型对象Person.prototype</p></li><li><p>构造函数生成实例对象person，person的__proto__指向构造函数Person原型对象</p></li><li><p>Person.prototype.<strong>proto</strong> 指向内置对象，因为 Person.prototype 是个对象，默认是由 Object函数作为类创建的，而 Object.prototype 为内置对象</p></li><li><p>Person.<strong>proto</strong> 指向内置匿名函数 anonymous，因为 Person 是个函数对象，默认由 Function 作为类创建</p></li><li><p>Function.prototype 和 Function.__proto__同时指向内置匿名函数 anonymous，这样原型链的终点就是 null</p></li></ul><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>下面首先要看几个概念：</p><p>__proto__作为不同对象之间的桥梁，用来指向创建它的构造函数的原型对象的</p><p><img src="'+k+`" alt="图片"></p><p>每个对象的__proto__都是指向它的构造函数的原型对象prototype的</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code>person1<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>构造函数是一个函数对象，是通过 Function构造器产生的</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code>Person<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>原型对象本身是一个普通对象，而普通对象的构造函数都是Object</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>刚刚上面说了，所有的构造器都是函数对象，函数对象都是 Function构造产生的</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code>Object<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Object的原型对象也有__proto__属性指向null，null是原型链的顶端</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token keyword">null</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>下面作出总结：</p><ul><li><p>一切对象都是继承自Object对象，Object 对象直接继承根源对象null</p></li><li><p>一切的函数对象（包括 Object 对象），都是继承自 Function 对象</p></li><li><p>Object 对象直接继承自 Function 对象</p></li><li><p>Function对象的__proto__会指向自己的原型对象，最终还是继承自Object对象</p></li></ul><h2 id="参考文献" tabindex="-1"><a class="header-anchor" href="#参考文献"><span>参考文献</span></a></h2>`,38),b={href:"https://juejin.cn/post/6870732239556640775#heading-7",target:"_blank",rel:"noopener noreferrer"},g={href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain",target:"_blank",rel:"noopener noreferrer"};function y(j,f){const t=o("router-link"),p=o("ExternalLinkIcon");return l(),i("div",null,[m,n("nav",_,[n("ul",null,[n("li",null,[s(t,{to:"#原型"},{default:e(()=>[a("原型")]),_:1})]),n("li",null,[s(t,{to:"#原型链"},{default:e(()=>[a("原型链")]),_:1})]),n("li",null,[s(t,{to:"#总结"},{default:e(()=>[a("总结")]),_:1})]),n("li",null,[s(t,{to:"#参考文献"},{default:e(()=>[a("参考文献")]),_:1})])])]),h,n("ul",null,[n("li",null,[n("a",b,[a("https://juejin.cn/post/6870732239556640775#heading-7"),s(p)])]),n("li",null,[n("a",g,[a("https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain"),s(p)])])])])}const w=c(v,[["render",y],["__file","index.html.vue"]]),O=JSON.parse('{"path":"/interview/js/prototype/","title":"JavaScript原型，原型链 ? 有什么特点？","lang":"zh-CN","frontmatter":{"title":"JavaScript原型，原型链 ? 有什么特点？","sidebarDepth":0,"date":"2024-06-03T00:00:00.000Z"},"headers":[{"level":2,"title":"原型","slug":"原型","link":"#原型","children":[]},{"level":2,"title":"原型链","slug":"原型链","link":"#原型链","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]},{"level":2,"title":"参考文献","slug":"参考文献","link":"#参考文献","children":[]}],"git":{"updatedTime":1717481375000,"contributors":[{"name":"chenxt","email":"chenxt@power-www.com","commits":1}]},"filePathRelative":"interview/js/prototype/index.md"}');export{w as comp,O as data};
