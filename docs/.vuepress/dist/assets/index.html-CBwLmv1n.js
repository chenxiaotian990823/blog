import{_ as p,r as l,o,c,a as n,b as s,w as i,d as a,e as r}from"./app-DtNyoU9e.js";const d={},u=n("h1",{id:"vue-项目本地开发完成后部署到服务器后报-404-是什么原因呢",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#vue-项目本地开发完成后部署到服务器后报-404-是什么原因呢"},[n("span",null,"vue 项目本地开发完成后部署到服务器后报 404 是什么原因呢？")])],-1),h={class:"table-of-contents"},v=r(`<h2 id="如何部署" tabindex="-1"><a class="header-anchor" href="#如何部署"><span>如何部署</span></a></h2><p>前后端分离开发模式下，前后端是独立布署的，前端只需要将最后的构建物上传至目标服务器的 web 容器指定的静态目录下即可</p><p>我们知道 vue 项目在构建后，是生成一系列的静态文件</p><p>常规布署我们只需要将这个目录上传至目标服务器即可</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>// <span class="token function">scp</span> 上传 user为主机登录用户，host为主机外网ip, xx为web容器静态资源路径
<span class="token function">scp</span> dist.zip user@host:/xx/xx/xx
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>让 web 容器跑起来，以 nginx 为例</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>server <span class="token punctuation">{</span>
  listen  <span class="token number">80</span><span class="token punctuation">;</span>
  server_name  www.xxx.com<span class="token punctuation">;</span>

  location / <span class="token punctuation">{</span>
    index  /data/dist/index.html<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置完成记得重启 nginx</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>// 检查配置是否正确
nginx <span class="token parameter variable">-t</span>

// 平滑重启
nginx <span class="token parameter variable">-s</span> reload
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>操作完后就可以在浏览器输入域名进行访问了</p><p>当然上面只是提到最简单也是最直接的一种布署方式</p><p>什么自动化，镜像，容器，流水线布署，本质也是将这套逻辑抽象，隔离，用程序来代替重复性的劳动，本文不展开</p><h2 id="_404-问题" tabindex="-1"><a class="header-anchor" href="#_404-问题"><span>404 问题</span></a></h2><p>这是一个经典的问题，相信很多同学都有遇到过，那么你知道其真正的原因吗？</p><p>我们先还原一下场景：</p><ul><li>vue 项目在本地时运行正常，但部署到服务器中，刷新页面，出现了 404 错误</li></ul><p>先定位一下，HTTP 404 错误意味着链接指向的资源不存在</p><p>问题在于为什么不存在？且为什么只有 history 模式下会出现这个问题？</p><h3 id="为什么-history-模式下有问题" tabindex="-1"><a class="header-anchor" href="#为什么-history-模式下有问题"><span>为什么 history 模式下有问题</span></a></h3><p>Vue 是属于单页应用（single-page application）</p><p>而 SPA 是一种网络应用程序或网站的模型，所有用户交互是通过动态重写当前页面，前面我们也看到了，不管我们应用有多少页面，构建物都只会产出一个 index.html</p><p>现在，我们回头来看一下我们的 nginx 配置</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>server <span class="token punctuation">{</span>
  listen  <span class="token number">80</span><span class="token punctuation">;</span>
  server_name  www.xxx.com<span class="token punctuation">;</span>

  location / <span class="token punctuation">{</span>
    index  /data/dist/index.html<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以根据 nginx 配置得出，当我们在地址栏输入 www.xxx.com 时，这时会打开我们 dist 目录下的 index.html 文件，然后我们在跳转路由进入到 www.xxx.com/login</p><p>关键在这里，当我们在 website.com/login 页执行刷新操作，nginx location 是没有相关配置的，所以就会出现 404 的情况</p><h3 id="为什么-hash-模式下没有问题" tabindex="-1"><a class="header-anchor" href="#为什么-hash-模式下没有问题"><span>为什么 hash 模式下没有问题</span></a></h3><p>router hash 模式我们都知道是用符号#表示的，如 website.com/#/login, hash 的值为 #/login</p><p>它的特点在于：hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对服务端完全没有影响，因此改变 hash 不会重新加载页面</p><p>hash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 website.com/#/login 只有 website.com 会被包含在请求中 ，因此对于服务端来说，即使没有配置 location，也不会返回 404 错误</p><h2 id="解决方案" tabindex="-1"><a class="header-anchor" href="#解决方案"><span>解决方案</span></a></h2><p>看到这里我相信大部分同学都能想到怎么解决问题了，</p><p>产生问题的本质是因为我们的路由是通过 JS 来执行视图切换的，</p><p>当我们进入到子路由时刷新页面，web 容器没有相对应的页面此时会出现 404</p><p>所以我们只需要配置将任意页面都重定向到 index.html，把路由交由前端处理</p><p>对 nginx 配置文件.conf 修改，添加 try_files $uri $uri/ /index.html;</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>server <span class="token punctuation">{</span>
  listen  <span class="token number">80</span><span class="token punctuation">;</span>
  server_name  www.xxx.com<span class="token punctuation">;</span>

  location / <span class="token punctuation">{</span>
    index  /data/dist/index.html<span class="token punctuation">;</span>
    try_files <span class="token variable">$uri</span> <span class="token variable">$uri</span>/ /index.html<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>修改完配置文件后记得配置的更新</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>nginx <span class="token parameter variable">-s</span> reload
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这么做以后，你的服务器就不再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件</p><p>为了避免这种情况，你应该在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">mode</span><span class="token operator">:</span> <span class="token string">&quot;history&quot;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">routes</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span> <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">&quot;*&quot;</span><span class="token punctuation">,</span> <span class="token literal-property property">component</span><span class="token operator">:</span> NotFoundComponent <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于后端配置方案还有：Apache、nodejs等，思想是一致的，这里就不展开述说了</p><h2 id="参考文献" tabindex="-1"><a class="header-anchor" href="#参考文献"><span>参考文献</span></a></h2>`,43),m={href:"https://juejin.cn/post/6844903872637632525",target:"_blank",rel:"noopener noreferrer"},b={href:"https://vue-js.com/topic/5f8cf91d96b2cb0032c385c0",target:"_blank",rel:"noopener noreferrer"};function k(x,g){const e=l("router-link"),t=l("ExternalLinkIcon");return o(),c("div",null,[u,n("nav",h,[n("ul",null,[n("li",null,[s(e,{to:"#如何部署"},{default:i(()=>[a("如何部署")]),_:1})]),n("li",null,[s(e,{to:"#_404-问题"},{default:i(()=>[a("404 问题")]),_:1}),n("ul",null,[n("li",null,[s(e,{to:"#为什么-history-模式下有问题"},{default:i(()=>[a("为什么 history 模式下有问题")]),_:1})]),n("li",null,[s(e,{to:"#为什么-hash-模式下没有问题"},{default:i(()=>[a("为什么 hash 模式下没有问题")]),_:1})])])]),n("li",null,[s(e,{to:"#解决方案"},{default:i(()=>[a("解决方案")]),_:1})]),n("li",null,[s(e,{to:"#参考文献"},{default:i(()=>[a("参考文献")]),_:1})])])]),v,n("ul",null,[n("li",null,[n("a",m,[a("https://juejin.cn/post/6844903872637632525"),s(t)])]),n("li",null,[n("a",b,[a("https://vue-js.com/topic/5f8cf91d96b2cb0032c385c0"),s(t)])])])])}const f=p(d,[["render",k],["__file","index.html.vue"]]),w=JSON.parse('{"path":"/interview/vue/deploy404/","title":"vue项目本地开发完成后部署到服务器后报404是什么原因呢？","lang":"zh-CN","frontmatter":{"title":"vue项目本地开发完成后部署到服务器后报404是什么原因呢？","sidebarDepth":0,"date":"2024-05-17T00:00:00.000Z"},"headers":[{"level":2,"title":"如何部署","slug":"如何部署","link":"#如何部署","children":[]},{"level":2,"title":"404 问题","slug":"_404-问题","link":"#_404-问题","children":[{"level":3,"title":"为什么 history 模式下有问题","slug":"为什么-history-模式下有问题","link":"#为什么-history-模式下有问题","children":[]},{"level":3,"title":"为什么 hash 模式下没有问题","slug":"为什么-hash-模式下没有问题","link":"#为什么-hash-模式下没有问题","children":[]}]},{"level":2,"title":"解决方案","slug":"解决方案","link":"#解决方案","children":[]},{"level":2,"title":"参考文献","slug":"参考文献","link":"#参考文献","children":[]}],"git":{"updatedTime":1715936165000,"contributors":[{"name":"chenxt","email":"chenxt@power-www.com","commits":1}]},"filePathRelative":"interview/vue/deploy404/index.md"}');export{f as comp,w as data};
